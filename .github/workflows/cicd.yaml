name: build-and-deploy

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

env:
  # <<< adjust these if needed >>>
  K8S_NAMESPACE: demo
  DEPLOYMENT_NAME: sample-nginx
  CONTAINER_NAME: sample-nginx
  CREATE_PULL_SECRET: "false"   # set "true" only if your Deployment uses imagePullSecrets: ghcr-pull

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_sha: ${{ steps.compute.outputs.image_sha }}
      owner_lc:  ${{ steps.compute.outputs.owner_lc }}
      repo_lc:   ${{ steps.compute.outputs.repo_lc }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute lowercase owner/repo (GHCR requires lowercase)
        id: compute
        shell: bash
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_LC=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "owner_lc=$OWNER_LC" >> $GITHUB_OUTPUT
          echo "repo_lc=$REPO_LC"   >> $GITHUB_OUTPUT
          echo "image_sha=ghcr.io/$OWNER_LC/$REPO_LC:${{ github.sha }}" >> $GITHUB_OUTPUT

      - uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (tags + labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.compute.outputs.owner_lc }}/${{ steps.compute.outputs.repo_lc }}
          tags: |
            type=sha
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      K8S_NAMESPACE: demo
      DEPLOYMENT_NAME: sample-nginx
      CONTAINER_NAME: sample-nginx
      KUBECONFIG: $HOME/.kube/config
      IMAGE_SHA: ${{ needs.build-and-push.outputs.image_sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.6

      - name: Write kubeconfig (raw OR base64), ensure context
        shell: bash
        env:
          KCFG_SECRET: ${{ secrets.KUBECONFIG_RAW }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.kube"

          # --- Write secret to temp, autodetect base64, normalize line-endings ---
          TMP=$(mktemp)
          printf "%s" "$KCFG_SECRET" > "$TMP"

          if ! grep -q '^apiVersion:' "$TMP"; then
            # try base64 decode
            if base64 -d "$TMP" > "$TMP.dec" 2>/dev/null && grep -q '^apiVersion:' "$TMP.dec"; then
              mv "$TMP.dec" "$TMP"
            fi
          fi

          tr -d '\r' < "$TMP" > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"

          echo "== kubeconfig header =="
          head -n 12 "$HOME/.kube/config" || true
          echo "======================="

          # --- Validate presence of clusters & users ---
          grep -q '^clusters:' "$HOME/.kube/config" || { echo "ERROR: kubeconfig missing 'clusters:'"; exit 1; }
          grep -q '^users:'    "$HOME/.kube/config" || { echo "ERROR: kubeconfig missing 'users:'"; exit 1; }

          # --- If no context, create one from first cluster+user ---
          if ! kubectl config get-contexts -o name >/dev/null 2>&1 || [ -z "$(kubectl config get-contexts -o name || true)" ]; then
            FIRST_CLUSTER=$(kubectl config view -o jsonpath='{.clusters[0].name}')
            FIRST_USER=$(kubectl config view -o jsonpath='{.users[0].name}')
            if [ -z "$FIRST_CLUSTER" ] || [ -z "$FIRST_USER" ]; then
              echo "ERROR: cannot determine cluster/user to create a context"; exit 1;
            fi
            kubectl config set-context temp --cluster="$FIRST_CLUSTER" --user="$FIRST_USER" >/dev/null
          fi

          # --- Ensure a current-context is selected ---
          if ! kubectl config current-context >/dev/null 2>&1; then
            CTX=$(kubectl config get-contexts -o name | head -n1)
            kubectl config use-context "$CTX"
          fi

          echo "Using context: $(kubectl config current-context)"
          kubectl cluster-info

      - name: Ensure namespace exists
        run: |
          kubectl get ns "$K8S_NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$K8S_NAMESPACE"

      - name: Create GHCR imagePullSecret (optional)
        if: env.CREATE_PULL_SECRET == 'true'
        run: |
          kubectl -n "$K8S_NAMESPACE" delete secret ghcr-pull >/dev/null 2>&1 || true
          kubectl -n "$K8S_NAMESPACE" create secret docker-registry ghcr-pull \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}"

      - name: Apply manifests (expects YAML under k8s/)
        run: kubectl apply -n "$K8S_NAMESPACE" -f k8s/

      - name: Patch deployment to new image
        run: |
          kubectl -n "$K8S_NAMESPACE" set image deployment/"$DEPLOYMENT_NAME" "$CONTAINER_NAME"="$IMAGE_SHA"

      - name: Wait for rollout
        run: |
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/"$DEPLOYMENT_NAME" --timeout=5m

