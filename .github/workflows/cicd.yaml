name: build-and-deploy

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write    # needed for GHCR
  id-token: write    # harmless here; useful if you later switch to OIDC

env:
  # ---- Deployment settings ----
  K8S_NAMESPACE: demo
  CREATE_PULL_SECRET: "false"   # set "true" if your GHCR repo is private AND your k8s Deployment uses imagePullSecrets: ghcr-pull

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.tags }}
      image_sha: ${{ steps.compute.outputs.image_sha }}
      owner_lc: ${{ steps.compute.outputs.owner_lc }}
      repo_lc:  ${{ steps.compute.outputs.repo_lc }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase owner/repo (GHCR requires lowercase)
        id: compute
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_LC=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "owner_lc=$OWNER_LC" >> $GITHUB_OUTPUT
          echo "repo_lc=$REPO_LC"   >> $GITHUB_OUTPUT
          echo "image_sha=ghcr.io/$OWNER_LC/$REPO_LC:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (tags + labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.compute.outputs.owner_lc }}/${{ steps.compute.outputs.repo_lc }}
          tags: |
            type=sha
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      K8S_NAMESPACE: ${{ env.K8S_NAMESPACE }}
      KUBECONFIG: $HOME/.kube/config
      IMAGE_SHA: ${{ needs.build-and-push.outputs.image_sha }}
      OWNER_LC:  ${{ needs.build-and-push.outputs.owner_lc }}
      REPO_LC:   ${{ needs.build-and-push.outputs.repo_lc }}
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.6

      - name: Write kubeconfig from base64 secret
        shell: bash
        run: |
          mkdir -p "$HOME/.kube"
          echo "${{ secrets.KUBECONFIG_B64 }}" | base64 -d > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"
          echo -n "Bytes in kubeconfig: "; wc -c < "$HOME/.kube/config"
          kubectl config view --minify
          kubectl cluster-info

      - name: Ensure namespace exists
        run: |
          kubectl get ns "$K8S_NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$K8S_NAMESPACE"

      # Optional: create imagePullSecret if your GHCR repo is private AND your Deployment references it
      - name: Create GHCR imagePullSecret (optional)
        if: env.CREATE_PULL_SECRET == 'true'
        run: |
          kubectl -n "$K8S_NAMESPACE" delete secret ghcr-pull >/dev/null 2>&1 || true
          kubectl -n "$K8S_NAMESPACE" create secret docker-registry ghcr-pull \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}"

      - name: Apply manifests
        run: |
          # assumes your Kubernetes yaml is under k8s/
          kubectl apply -n "$K8S_NAMESPACE" -f k8s/

      # If your Deployment name is "app" and container is "app", update it to the new image tag
      - name: Patch deployment to current image (commit SHA)
        run: |
          # adjust names if different:
          DEPLOYMENT_NAME=$(kubectl -n "$K8S_NAMESPACE" get deploy -o jsonpath='{.items[0].metadata.name}')
          CONTAINER_NAME=$(kubectl -n "$K8S_NAMESPACE" get deploy "$DEPLOYMENT_NAME" -o jsonpath='{.spec.template.spec.containers[0].name}')
          echo "Patching $DEPLOYMENT_NAME/$CONTAINER_NAME to $IMAGE_SHA"
          kubectl -n "$K8S_NAMESPACE" set image deployment/"$DEPLOYMENT_NAME" "$CONTAINER_NAME"="$IMAGE_SHA"

      - name: Wait for rollout
        run: |
          DEPLOYMENT_NAME=$(kubectl -n "$K8S_NAMESPACE" get deploy -o jsonpath='{.items[0].metadata.name}')
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/"$DEPLOYMENT_NAME" --timeout=5m

