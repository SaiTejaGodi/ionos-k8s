name: build-and-deploy

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

# Simple constants only (no expressions here)
env:
  K8S_NAMESPACE: demo             # <-- change if needed
  DEPLOYMENT_NAME: sample-nginx   # <-- change if your Deployment has a different name
  CONTAINER_NAME: sample-nginx    # <-- change if your container has a different name
  CREATE_PULL_SECRET: "false"     # set "true" only if your Deployment uses imagePullSecrets: ghcr-pull

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_sha: ${{ steps.compute.outputs.image_sha }}
      owner_lc:  ${{ steps.compute.outputs.owner_lc }}
      repo_lc:   ${{ steps.compute.outputs.repo_lc }}
    steps:
      - uses: actions/checkout@v4

      - name: Compute lowercase owner/repo (GHCR requires lowercase)
        id: compute
        shell: bash
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_LC=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "owner_lc=$OWNER_LC" >> $GITHUB_OUTPUT
          echo "repo_lc=$REPO_LC"   >> $GITHUB_OUTPUT
          echo "image_sha=ghcr.io/$OWNER_LC/$REPO_LC:${{ github.sha }}" >> $GITHUB_OUTPUT

      - uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata (tags + labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.compute.outputs.owner_lc }}/${{ steps.compute.outputs.repo_lc }}
          tags: |
            type=sha
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    env:
      K8S_NAMESPACE: demo
      DEPLOYMENT_NAME: sample-nginx
      CONTAINER_NAME: sample-nginx
      KUBECONFIG: $HOME/.kube/config
      IMAGE_SHA: ${{ needs.build-and-push.outputs.image_sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.6

      - name: Write kubeconfig (RAW secret) + set context
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.kube"
          # Write kubeconfig exactly as stored in the secret (no base64 decoding)
          printf "%s" "${{ secrets.KUBECONFIG_RAW }}" > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"

          echo "Sanity check (top of kubeconfig):"
          head -n 15 "$HOME/.kube/config" || true

          # Ensure kubeconfig has contexts and select one if none selected
          if ! grep -qE '(^contexts:)' "$HOME/.kube/config"; then
            echo "ERROR: kubeconfig has no 'contexts:' section. Check your KUBECONFIG_RAW secret."
            exit 1
          fi

          if ! kubectl config current-context >/dev/null 2>&1; then
            CTX=$(kubectl config get-contexts -o name | head -n 1)
            [ -n "$CTX" ] || { echo "ERROR: no contexts available in kubeconfig"; exit 1; }
            kubectl config use-context "$CTX"
          fi

          echo "Using context: $(kubectl config current-context)"
          kubectl cluster-info

      - name: Ensure namespace exists
        run: |
          kubectl get ns "$K8S_NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$K8S_NAMESPACE"

      - name: Create GHCR imagePullSecret (optional)
        if: env.CREATE_PULL_SECRET == 'true'
        run: |
          kubectl -n "$K8S_NAMESPACE" delete secret ghcr-pull >/dev/null 2>&1 || true
          kubectl -n "$K8S_NAMESPACE" create secret docker-registry ghcr-pull \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}"

      - name: Apply manifests (expects your YAML under k8s/)
        run: kubectl apply -n "$K8S_NAMESPACE" -f k8s/

      - name: Patch deployment to new image
        run: |
          kubectl -n "$K8S_NAMESPACE" set image deployment/"$DEPLOYMENT_NAME" "$CONTAINER_NAME"="$IMAGE_SHA"

      - name: Wait for rollout
        run: |
          kubectl -n "$K8S_NAMESPACE" rollout status deployment/"$DEPLOYMENT_NAME" --timeout=5m

